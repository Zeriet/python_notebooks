package com.ge.current.em.rules;

import java.io.Serializable;
import java.util.List;
import java.util.Arrays;
import java.util.Map;
import java.lang.Double;
import java.lang.Math;

import com.ge.current.em.entities.analytics.*;
import com.ge.current.em.util.TagConstants;
import com.ge.current.em.util.GeneralUtil;
import com.ge.current.em.util.RulesUtil;
import java.util.ArrayList
import java.util.HashMap;

rule "Heating does not work"
dialect "java"
no-loop true
when
$data : RulesBaseFact($assetId: assetId,
$segmentId: segmentId,
$enterpriseId: enterpriseId,
$siteId: siteId,
$measuresAvgMap: measuresAvgMap,
$measuresAggrMap: measuresAggrMap,
$alarmObject: alarmObject,
$conditionMet: conditionMet,
$parameters: parameters,
detectFaultForHeatingDoesNotWork($measuresAvgMap,$measuresAggrMap, $parameters, $alarmObject))
then
$alarmObject.setAssetId($assetId);
$alarmObject.setAlertName(RulesUtil.HEATING_DOES_NOT_WORK);
$alarmObject.setAlertType(RulesUtil.HEATING_DOES_NOT_WORK);
$alarmObject.setCategory(RulesUtil.CATEGORY);
$alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_EQUIPMENT);
$data.setAlarmObject($alarmObject);
$data.setConditionMet(true);
GeneralUtil.log(RulesUtil.HEATING_DOES_NOT_WORK, GeneralUtil.LEVEL_INFO, "Alarm triggered.");
retract($data);
end


function boolean detectFaultForHeatingDoesNotWork(Object measuresAvgObject,Object measuresAggrObject, Object parametersObject, Object alarmObject) {
    String heatingDoesNotWorkRuleName = RulesUtil.HEATING_DOES_NOT_WORK;
    String minITDKeyName = TagConstants.Parameters.MIN_ITD.getParameterName() + RulesUtil.getFDSINumber(heatingDoesNotWorkRuleName);
    String runtimeThresholdName = TagConstants.Parameters.RUNTIME_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(heatingDoesNotWorkRuleName);

    boolean faultDetected = false;

    if(measuresAvgObject == null || measuresAggrObject ==null || parametersObject == null) {
        return faultDetected;
    }

    List<Map<String, Object>> measuresAvg = (List<Map<String, Object>>) measuresAvgObject;
    List<Map<String, Object>> measuresAggr = (List<Map<String, Object>>) measuresAggrObject;
        Map<String,Object> parameters = (Map<String,Object>) parametersObject;

    String ahuHeatStage1OnRunTime = TagConstants.Tags.AHU_HEAT_STAGE_1_ON_RUNTIME.getTagName();
    String rtuHeatStage1OnRunTime = TagConstants.Tags.RTU_HEAT_STAGE_1_ON_RUNTIME.getTagName();

    List<String> requiredTags = Arrays.asList(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(),
                minITDKeyName,
                TagConstants.Tags.DISCHARGE_AIR_TEMP_SENSOR.getTagName());
    List<String> requiredAnyTags = Arrays.asList(ahuHeatStage1OnRunTime, rtuHeatStage1OnRunTime);

     if(!measuresAvg.isEmpty() && !parameters.isEmpty() && !measuresAggr.isEmpty()){

        List<String> tagsToBeChecked = new ArrayList<>();
          tagsToBeChecked.addAll(measuresAvg.get(0).keySet());
          tagsToBeChecked.addAll(measuresAggr.get(0).keySet());
          tagsToBeChecked.addAll(parameters.keySet());

          if(!RulesUtil.areAnyTagsValid(heatingDoesNotWorkRuleName, tagsToBeChecked, requiredAnyTags)){
             return faultDetected;
          }

        if(!RulesUtil.areTagsValid(heatingDoesNotWorkRuleName, tagsToBeChecked, requiredTags)) {
            GeneralUtil.log(heatingDoesNotWorkRuleName, GeneralUtil.LEVEL_INFO, "Tags are not valid.");
            return faultDetected;
         }
    }

    if(parameters.get(minITDKeyName) == null || parameters.get(runtimeThresholdName) == null){
        GeneralUtil.log(heatingDoesNotWorkRuleName, GeneralUtil.LEVEL_INFO," parameters.get(minITDKeyName) or parameters.get(runtimeThresholdName) is null");
        return faultDetected;
    }

    Double minITD = (Double) parameters.get(minITDKeyName);
    Double runtimeThresholdValue = (Double) parameters.get(runtimeThresholdName);
    String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.HEATING_DOES_NOT_WORK);

    GeneralUtil.log(heatingDoesNotWorkRuleName, GeneralUtil.LEVEL_INFO, "Heating does not work, runtimeThresholdValue: " + runtimeThresholdValue);

    /* checking condition met*/
    if(getTotalHeatStage1OnRuntime(measuresAggrObject, (Object) ahuHeatStage1OnRunTime) < runtimeThresholdValue &&  getTotalHeatStage1OnRuntime(measuresAggrObject, (Object) rtuHeatStage1OnRunTime) < runtimeThresholdValue ){
         GeneralUtil.log(heatingDoesNotWorkRuleName, GeneralUtil.LEVEL_WARN, "Condition is not met");
         return faultDetected;
    }

    Map<String, Object> results = (Map<String, Object>) getResultHeatingDoesNotWork(measuresAvgObject, (Object) minITD);
    faultDetected = (boolean) results.get("detectFault");

    if(!faultDetected) {
        return faultDetected;
    }
    String startAlertTime = (String) results.get("startAlert");
    Double duration  = (Double) results.get("duration");
    AlarmObject alarm = (AlarmObject) alarmObject;
    alarm.setSeverity((Double) parameters.get(TagConstants.Parameters.SEVERITY.getParameterName()));
    alarm.setDuration(duration);
    alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY);
    alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE);
    alarm.setTimeOfAlert(startAlertTime);

    if (parameters.get(severityKeyName) != null) {
        alarm.setSeverity((Double) parameters.get(severityKeyName));
    }

    alarmObject = alarm;
    return faultDetected;
}

/* getting the total runtime for eacht tag considered*/
function Double getTotalHeatStage1OnRuntime(Object measuresAggrMapObject, Object hvacStatusOnRuntimeTagName){
      List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresAggrMapObject;
      String hvacStatusOnRuntimeTag = (String) hvacStatusOnRuntimeTagName;
      Double hvacStatusOnRuntimeSum = measures.stream().filter(m -> m.get(hvacStatusOnRuntimeTag) != null)
                                                             .mapToDouble(s -> (Double) s.get(hvacStatusOnRuntimeTag)).sum();
     return  hvacStatusOnRuntimeSum/60;

}


function Object getResultHeatingDoesNotWork(Object measuresAvgMapObject, Object minItdValue){

    Map<String, Object> result = new HashMap<>();
    String startAlert = null;
    boolean detectFault = false;
    double minItd = (double) minItdValue;
    List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresAvgMapObject;
    String zoneAirTempSensor = TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName();
    String dischargeAirTempSensor = TagConstants.Tags.DISCHARGE_AIR_TEMP_SENSOR.getTagName();
    Double duration = 0.0;

    for (Map<String, Object> currentMapMeasure: measures){
        if (currentMapMeasure.get(dischargeAirTempSensor) != null && currentMapMeasure.get(zoneAirTempSensor) != null){
            Double itd = (Double) currentMapMeasure.get(dischargeAirTempSensor) - (Double) currentMapMeasure.get(zoneAirTempSensor);
            if (itd > minItd){
              detectFault = true;
              if (currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()) != null && startAlert == null) {
                startAlert = currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString();
              }
              duration += 15.00;
            }
        }
    }

    result.put("detectFault", detectFault);
    result.put("startAlert", startAlert);
    result.put("duration", duration);
    GeneralUtil.log(RulesUtil.HEATING_DOES_NOT_WORK, GeneralUtil.LEVEL_INFO,"detectFault: " + detectFault + " duration: " + duration + " minItd: " + minItd + " Start Alert time: " + startAlert);
    return (Object) result;

  }



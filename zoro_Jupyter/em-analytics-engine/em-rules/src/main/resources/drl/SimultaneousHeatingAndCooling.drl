package com.ge.current.em.rules;

import java.lang.Double;
import java.lang.Math;
import java.io.Serializable;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.ge.current.em.entities.analytics.*;
import com.ge.current.em.util.TagConstants;
import com.ge.current.em.util.GeneralUtil;
import com.ge.current.em.util.RulesUtil
import java.util.HashMap
import java.util.Stack;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

rule "Simultaneous Heating and Cooling"
dialect "java"
no-loop true
when
$data : RulesBaseFact($assetId: assetId,
$tagsMap: tagsMap,
$segmentId: segmentId,
$enterpriseId: enterpriseId,
$siteId: siteId,
$alarmObject: alarmObject,
$conditionMet: conditionMet,
$parameters: parameters,
detectFaultForSimultaneousHeatingAndCoolingRTU($tagsMap, $parameters, $alarmObject))
then
$alarmObject.setAssetId($assetId);
$alarmObject.setAlertName(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING);
$alarmObject.setAlertType(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING);
$alarmObject.setCategory(RulesUtil.CATEGORY);
$alarmObject.setFaultCategory(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING);
$data.setAlarmObject($alarmObject);
$data.setConditionMet(true);
end

function boolean detectFaultForSimultaneousHeatingAndCoolingRTU( Object tagsMapObject, Object parametersObject, Object alarmObject) {
    final Logger LOG = LoggerFactory.getLogger(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING);
    boolean faultDetected = false;

    if(tagsMapObject == null || parametersObject == null) {
        LOG.error("Neither tags nor parameters can be null");
        return faultDetected;
    }

    AlarmObject alarm = (AlarmObject) alarmObject;
    Map<String, Object> parameters = (Map<String, Object>)parametersObject;
    List<Map<String, Object>> tags = (List<Map<String, Object>>)tagsMapObject;

    if (!areTagsValidForSimultaneousHeatingAndCoolingRTU((Object)tags.get(0), parametersObject)) {
        return faultDetected;
    }

    String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName()
        + RulesUtil.getFDSINumber(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING);

    Map<String, Object> result = (Map<String, Object>)getResultForSimultaneousHeatingAndCoolingRTU(tagsMapObject);

    faultDetected = (boolean) result.get(RulesBaseFact.CONDITION_MET_FIELDNAME);
    if (faultDetected) {

        if (result.get(AlarmObject.START_ALERT_FIELDNAME) == null) {
            LOG.error("Fault was detected but start alert is null, triggering alarm is cancelled.");
            return false;
        }

        Double actualDuration = (Double) result.get(TagConstants.Parameters.DURATION.getParameterName());
        alarm.setSeverity((Double) parameters.get(severityKeyName));
        alarm.setDuration(actualDuration);
        alarm.setTimeOfAlert(result.get(AlarmObject.START_ALERT_FIELDNAME).toString());
        alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY);
        alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_NORM_LOG);
        alarmObject = alarm;
        LOG.info("Fault detected! Triggering alarm...");
    }
    return  faultDetected;
}

function boolean areTagsValidForSimultaneousHeatingAndCoolingRTU(Object firstMapOfTags, Object parametersObject) {
    final Logger LOG = LoggerFactory.getLogger(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING);
    Map<String, Object> tags = (Map<String, Object>)firstMapOfTags;
    Map<String, Object> parameters = (Map<String, Object>)parametersObject;

    String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING);

    List<String> requiredTags = Arrays.asList(TagConstants.Tags.AHU_COOL_STAGE_1.getTagName(), TagConstants.Tags.AHU_HEAT_STAGE_1.getTagName(), TagConstants.Measures.EVENT_TS.getMeasureName());
    List<String> requiredParameters = Arrays.asList(severityKeyName);

    if (!tags.isEmpty() && !parameters.isEmpty()) {
        List<String> tagsToBeChecked = new ArrayList<>();
        List<String> parametersToBeChecked = new ArrayList<>();

        tagsToBeChecked.addAll(tags.keySet());
        parametersToBeChecked.addAll(parameters.keySet());

        if (!RulesUtil.areTagsValid(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING, tagsToBeChecked, requiredTags)) {
            LOG.info("Tags are not valid.");
            return false;
        }

        if (!RulesUtil.areTagsValid(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING, parametersToBeChecked, requiredParameters)) {
            LOG.info("Parameters are not valid.");
            return false;
        }

    } else {
        LOG.warn("Measures and parameters are empty.");
        return false;
    }
    return true;
}

function Object getResultForSimultaneousHeatingAndCoolingRTU(Object tagsMapObject) {
    final Logger LOG = LoggerFactory.getLogger(RulesUtil.SIMULTANEOUS_HEATING_AND_COOLING);
    Map<String, Object> result = new HashMap<>();
    result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, false);
    result.put(AlarmObject.START_ALERT_FIELDNAME, null);
    String startAlert = null;

    boolean coolCmdDetected = false;
    boolean heatCmdDetected = false;

    String coolStg1CmdKeyName = TagConstants.Tags.AHU_COOL_STAGE_1.getTagName();
    String heatStg1CmdKeyName = TagConstants.Tags.AHU_HEAT_STAGE_1.getTagName();

    List<Map<String, Object>> tags = (List<Map<String, Object>>) tagsMapObject;
    Double duration = 0.0;

    for (Map<String, Object> currentTag : tags) {
        String currentCoolingCmd = (String)currentTag.get(coolStg1CmdKeyName);
        String currentHeatingCmd = (String)currentTag.get(heatStg1CmdKeyName);

        LOG.info("Current commands: cooling:{}, heating:{}", currentCoolingCmd, currentHeatingCmd);

        coolCmdDetected = currentCoolingCmd.toLowerCase().equals(TagConstants.ON_COMMAND_STATUS) ? true : false;
        heatCmdDetected = currentHeatingCmd.toLowerCase().equals(TagConstants.ON_COMMAND_STATUS) ? true : false;

        if (coolCmdDetected && heatCmdDetected) {
            duration += 15;
            if (startAlert == null) {
                if(currentTag.get(TagConstants.Measures.EVENT_TS.getMeasureName()) != null) {
                    String eventTs = currentTag.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString();
                    if(eventTs != null) {
                        startAlert = eventTs;
                        result.put(AlarmObject.START_ALERT_FIELDNAME, startAlert);
                    }
                }
            }
            result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, true);
        }
    }
    result.put(TagConstants.Parameters.DURATION.getParameterName(), duration);
    LOG.info("Result: " + result);
    return (Object) result;
}

package com.ge.current.em.rules;

import java.lang.Double;
import java.lang.Math;
import java.io.Serializable;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.ge.current.em.entities.analytics.*;
import com.ge.current.em.util.TagConstants;
import com.ge.current.em.util.GeneralUtil;
import com.ge.current.em.util.RulesUtil
import java.util.HashMap
import java.util.Stack;

rule "Short Cycling - Thermostat State"
dialect "java"
no-loop true
when
$data : RulesBaseFact($assetId: assetId,
$tagsMap: tagsMap,
$segmentId: segmentId,
$enterpriseId: enterpriseId,
$siteId: siteId,
$alarmObject: alarmObject,
$conditionMet: conditionMet,
$parameters: parameters,
detectFaultForShortCyclingThermostatState($tagsMap, $parameters, $alarmObject))
then
$alarmObject.setAssetId($assetId);
$alarmObject.setAlertName(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE);
$alarmObject.setAlertType(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE);
$alarmObject.setCategory(RulesUtil.CATEGORY);
$alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_PERFORMANCE);
$data.setAlarmObject($alarmObject);
$data.setConditionMet(true);
GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_INFO, "Alarm triggered.");
end

function boolean detectFaultForShortCyclingThermostatState( Object tagsMapObject, Object parametersObject, Object alarmObject) {
    boolean faultDetected = false;

    if(tagsMapObject == null || parametersObject == null) {
        return faultDetected;
    }

    List<Map<String, Object>> tags = (List<Map<String, Object>>) tagsMapObject;
    Map<String, Object> parameters = (Map<String, Object>) parametersObject;

   GeneralUtil.log("tags Map object: " + tags + "parametersObject" + parameters);
  /* for now we are assuming any of the below tags to be available*/

   List<String> requiredAnyTags = Arrays.asList(TagConstants.Tags.AHU_COOL_STAGE_1.getTagName(), TagConstants.Tags.AHU_HEAT_STAGE_1.getTagName(), TagConstants.Tags.RTU_COOL_STAGE1.getTagName(), TagConstants.Tags.RTU_HEAT_STAGE1.getTagName());
   List<String> requiredParameters = Arrays.asList(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE));
     if(!tags.isEmpty() && !parameters.isEmpty()){
          List<String> tagsToBeChecked = new ArrayList<>();
          List<String> parametersToBeChecked = new ArrayList<>();

          tagsToBeChecked.addAll(tags.get(0).keySet());
          parametersToBeChecked.addAll(parameters.keySet());

          if(!RulesUtil.areAnyTagsValid(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, tagsToBeChecked, requiredAnyTags)) {
              GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_INFO, "Tags are not valid.");
              return faultDetected;
           }
          if(!RulesUtil.areTagsValid(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, parametersToBeChecked, requiredParameters)) {
             GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_INFO, "Tags are not valid.");
             return faultDetected;
           }
      } else {
          GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_WARN, "One or more of these is empty: tags, or parameters");
          return faultDetected;
      }

    Map<String, Object> results = (Map<String, Object>) getShortCyclingThermostatStateResult(tagsMapObject, parametersObject);
    faultDetected = (boolean) results.get("detectFault");

        if(!faultDetected) {
            return faultDetected;
        }
        String startAlertTime = (String) results.get("startAlert");
        Double duration  = (Double) results.get("duration");
        AlarmObject alarm = (AlarmObject) alarmObject;
        String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE);
        if (parameters.get(severityKeyName) != null) {
            alarm.setSeverity((Double) parameters.get(severityKeyName));
        }
        alarm.setDuration(duration);
        alarm.setTimeOfAlert(startAlertTime);
        alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY);
        alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_NORM_LOG);
        alarmObject = alarm;
        return faultDetected;

}

/* getting the number of on off cycles for each tag considered */
function Map<String, Integer> getNumOfOnOffCycles(Object onOfMapObject){
    Map<String, List<String>> onOfCyclesMap = (Map<String, List<String>>) onOfMapObject;
    Map<String, Integer> onOfCycleCounts = new HashMap<>();
    List<List<String>> cycleList = getPossibleCyclesShortCyclingThermostatState();
    for(String cmdKey: onOfCyclesMap.keySet()){
        List<String> cmdList = onOfCyclesMap.get(cmdKey);
        int cycleCount = 0;
        for(int i = TagConstants.ON_OFF_WINDOW_LENGTH-1; i < cmdList.size(); i++ ){
            List<String> cmdSubList = cmdList.subList(i-(TagConstants.ON_OFF_WINDOW_LENGTH - 1),i +1);
            GeneralUtil.log(" ******* cmd key ****** " + cmdKey + " ******* Cmd List = " + cmdList + " ******* " +cmdSubList);
            boolean cycleDetected = cycleList.stream().anyMatch(cycle -> cycle.equals(cmdSubList));
            if (cycleDetected) cycleCount++;
         }
         onOfCycleCounts.put(cmdKey, cycleCount);
    }
    return onOfCycleCounts;
}

/* detecting if a given list of commands is a cycle */
function Boolean detectCycle(Object cmdSubList){
    /* possible cycle combinations of */
     List<String> cmdSublit = (List<String>) cmdSubList;
     List<List<String>> cycleList = getPossibleCyclesShortCyclingThermostatState();
     boolean cycleDetected = cycleList.stream().anyMatch(cycle -> cycle.equals(cmdSublit));
     return cycleDetected;
}
/* Getting possible cycle lists */
function List<List<String>> getPossibleCyclesShortCyclingThermostatState(){
        List<List<String>> cycleList = new ArrayList<List<String>>();
        List<String> cycle1 = Arrays.asList(TagConstants.ON_COMMAND_STATUS, TagConstants.OFF_COMMAND_STATUS, TagConstants.ON_COMMAND_STATUS);
        List<String> cycle2 = Arrays.asList(TagConstants.OFF_COMMAND_STATUS, TagConstants.ON_COMMAND_STATUS, TagConstants.OFF_COMMAND_STATUS);
        cycleList.add(cycle1);
        cycleList.add(cycle2);
        return  cycleList;
}


function Object getShortCyclingThermostatStateResult(Object tagsMapObject, Object parametersObject){

    Map<String, Object> result = new HashMap<>();
    String startAlert = null;
    boolean detectFault = false;
    List<Map<String, Object>> tags = (List<Map<String, Object>>) tagsMapObject;
    Double duration = 0.0;
    Map<String, Object> parameters = (Map<String, Object>) parametersObject;
    String userThresholdStr = "user_Threshold" + RulesUtil.getFDSINumber(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE);
    double userThreshold = (Double) parameters.get(userThresholdStr);
    List<String> requiredAnyTags = Arrays.asList(TagConstants.Tags.RTU_COOL_STAGE1.getTagName(), TagConstants.Tags.RTU_HEAT_STAGE1.getTagName(), TagConstants.Tags.AHU_COOL_STAGE_1.getTagName(), TagConstants.Tags.AHU_HEAT_STAGE_1.getTagName());

     List<String> tagsNeeded = new ArrayList<>(tags.get(0).keySet());
     List<String> tagsForOnOffCycle = RulesUtil.getNeededTagsFromTags(tagsNeeded, requiredAnyTags);
     Map<String, List<String>> onOfCyclesMap = new HashMap<>();

        for (Map<String, Object> currentTag: tags){
                for(String cmd: tagsForOnOffCycle){
                    String cmdStatus = (String) currentTag.get(cmd);
                        List<String> updatedOnOffList  = new ArrayList<>();
                        if (!onOfCyclesMap.isEmpty() && onOfCyclesMap.containsKey(cmd)){
                             updatedOnOffList  = (List<String>) onOfCyclesMap.get(cmd);
                             updatedOnOffList.add(cmdStatus);
                         } else {
                            updatedOnOffList.add(cmdStatus);
                         }
                    onOfCyclesMap.put(cmd, updatedOnOffList);
                }

            Map<String, Integer> onOffCycleCounts = getNumOfOnOffCycles((Object) onOfCyclesMap);
            int sumOnOffCyles = onOffCycleCounts.values().stream().mapToInt(Integer::intValue).sum();
             if (sumOnOffCyles > userThreshold){
                duration += 5;
                detectFault = true;
                 if(startAlert == null){
                    startAlert = currentTag.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString();
                  }
             }
         }

    result.put("detectFault", detectFault);
    result.put("startAlert", startAlert);
    result.put("duration", duration);
    GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_INFO, "duration: " + duration + " userThreshold " + userThreshold + "Start Alert time" + startAlert);

    return (Object) result;

}


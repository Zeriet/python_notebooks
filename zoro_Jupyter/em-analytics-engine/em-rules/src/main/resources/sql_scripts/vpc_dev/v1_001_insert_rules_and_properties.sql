-- --------------------------------------------------------------------------------
-- Program Name: v1_001_insert_rules_and_properties.sql
--
--      Purpose: insert rules and other required information.
--               Execute as '${schema_name}' dbuser or as superuser.
--
--       Inputs: None
--
--      Outputs: None
--
--      Commits: Yes
--
-- ---------------------------------------------------------------------------------
-- Modifications:
-- Date:      By:         Modified:
-- ---------------------------------------------------------------------------------
-- 01/11/2017 M.Flores   Initial version.
-- 01/19/2017 Z.Woldeab  Updated for new rules
-- ---------------------------------------------------------------------------------

SET search_path to emsdev_emsrules;

TRUNCATE emsdev_emsrules.rule CASCADE;
TRUNCATE emsdev_emsrules.document_log;


/* insert rules */
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-01','Zone Temperature Too High',DEFAULT,'DOC-UID-01',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Zone temperature exceeds a user defined temperature threshold for at least a user defined duration.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-02','Zone Temperature Too Low',DEFAULT,'DOC-UID-02',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Zone temperature exceeds a user defined temperature threshold for at least a user defined duration.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-03','Discharge Air Fan Failure',DEFAULT,'DOC-UID-03',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Air fan current is below a user defined threshold when there is a call for fan. Requires a current sensor on the air fan circuit.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-04','Short Cycling',DEFAULT,'DOC-UID-04',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Number of times the HVAC system is cycling from Heating/Cooling ON to OFF exceeds a user defined threshold.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-05','Excessive HVAC Overrides',DEFAULT,'DOC-UID-05',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Number of HVAC overrides exceeds a user defined threshold.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-06','Excessive Lighting Overrides',DEFAULT,'DOC-UID-06',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Number of Lighting overrides exceeds a user defined threshold.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-07','Excessive HVAC Overrides Runtime',DEFAULT,'DOC-UID-07',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'HVAC runtime during override state exceeds a user defined threshold.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-09','Zone Cooling Delta T Too High',DEFAULT,'DOC-UID-09',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'While Cooling for at least a user defined duration, the temperature differential between supply and zone temperature sensors exceeds a user defined threshold.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-12','Zone Heating Delta T Too High',DEFAULT,'DOC-UID-12',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'While Heating for at least a user defined duration, the temperature differential between supply and zone temperature sensors exceeds a user defined threshold.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-20','Zone Cooling Setpoint Unreachable',DEFAULT,'DOC-UID-20',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Zone temperature cannot reach the cooling setpoint (plus optional offset) within a user defined duration.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-21','Zone Heating Setpoint Unreachable',DEFAULT,'DOC-UID-21',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Zone temperature cannot reach the heating setpoint (minus optional offset) within a user defined duration.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-22','Excessive HVAC Usage After Hours',DEFAULT,'DOC-UID-22',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'HVAC runtime exceeds a user defined threshold during unoccupied times.','team analytics',DEFAULT,DEFAULT);
INSERT INTO emsdev_emsrules.rule (rule_id,rule_uid,rule_name,rule_type,document_uid,source_rule_id,from_date,thru_date,description,authored_by,update_timestamp,entry_timestamp) VALUES (DEFAULT,'RULE-UID-23','Excessive Lighting Usage After Hours',DEFAULT,'DOC-UID-23',(SELECT currval('emsdev_emsrules.rule_id_seq')),DEFAULT,DEFAULT,'Lighting runtime exceeds a user defined threshold during unoccupied times.', 'team analytics',DEFAULT,DEFAULT);


/* insert document logs */
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Zone Temperature Too High'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.lang.Math; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import com.ge.current.em.util.TagConstants import java.util.Date import java.util.HashMap; rule "Too hot threshold" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAvgMap: measuresAvgMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForTooHotThreshold($measuresAvgMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.TOO_HOT_THRESHOLD); $alarmObject.setAlertType(RulesUtil.TOO_HOT_THRESHOLD); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_PERFORMANCE); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.TOO_HOT_THRESHOLD, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForTooHotThreshold(Object measuresObject, Object parametersObject, Object alarmObject) { GeneralUtil.log(RulesUtil.TOO_HOT_THRESHOLD, GeneralUtil.LEVEL_WARN, "Tags are not valid."); boolean faultDetected = false; if(measuresObject == null || parametersObject == null || alarmObject == null) { return faultDetected; } String comfortThresholdKeyName = TagConstants.Parameters.COMFORT_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_HOT_THRESHOLD); String durationThresholdKeyName = TagConstants.Parameters.DURATION.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_HOT_THRESHOLD); String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_HOT_THRESHOLD); AlarmObject alarm = (AlarmObject) alarmObject; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; List<String> requiredTags = Arrays.asList(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(), comfortThresholdKeyName, durationThresholdKeyName, severityKeyName); if(!measures.isEmpty() && !parameters.isEmpty()) { List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measures.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areTagsValid(RulesUtil.TOO_HOT_THRESHOLD, tagsToBeChecked, requiredTags)) { GeneralUtil.log(RulesUtil.TOO_HOT_THRESHOLD, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(RulesUtil.TOO_HOT_THRESHOLD, GeneralUtil.LEVEL_WARN, "Measures and/or parameters is empty."); return faultDetected; } Double comfortThreshold = (Double) parameters.get(comfortThresholdKeyName); Double durationThreshold = (Double) parameters.get(durationThresholdKeyName); /* detect fault */ Map<String, Object> qualifyingFields = (Map<String, Object>) getConditionMetObjectForTooHotThreshold(measuresObject, comfortThreshold, durationThreshold); faultDetected = (boolean) qualifyingFields.get(RulesBaseFact.CONDITION_MET_FIELDNAME); if(faultDetected) { Double actualDuration = (Double) qualifyingFields.get(TagConstants.Parameters.DURATION.getParameterName()); alarm.setSeverity((Double) parameters.get(severityKeyName)); alarm.setDuration(actualDuration); alarm.setTimeOfAlert(qualifyingFields.get(AlarmObject.START_ALERT_FIELDNAME).toString()); alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; } return faultDetected; } function Object getConditionMetObjectForTooHotThreshold(Object measuresObject, Double comfortThreshold, Double durationThreshold) { Double duration = 0.0; String startAlert = null; Map<String, Object> result = new HashMap<>(); result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, false); List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; for(Map<String, Object> currentMeasure : measures) { if(currentMeasure.get(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName()) != null && currentMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()) != null) { Double currentZoneAirTempSensor = (Double) currentMeasure.get(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName()); GeneralUtil.log(RulesUtil.TOO_HOT_THRESHOLD, GeneralUtil.LEVEL_INFO, "Checking if current measure: " + currentZoneAirTempSensor + " is > comfortThreshold: " + comfortThreshold); if(currentZoneAirTempSensor > comfortThreshold) { duration += 15.0; GeneralUtil.log(RulesUtil.TOO_HOT_THRESHOLD, GeneralUtil.LEVEL_INFO, "Checking if current duration: " + duration + " is >= durationThreshold: " + durationThreshold); if(duration >= durationThreshold) { if(result.get(AlarmObject.START_ALERT_FIELDNAME) == null) { startAlert = currentMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); GeneralUtil.log(RulesUtil.TOO_HOT_THRESHOLD, GeneralUtil.LEVEL_INFO, "Start time of alert: " + startAlert); result.put(AlarmObject.START_ALERT_FIELDNAME, startAlert); } result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, true); result.put(TagConstants.Parameters.DURATION.getParameterName(), duration); } } } } GeneralUtil.log(RulesUtil.TOO_HOT_THRESHOLD, GeneralUtil.LEVEL_INFO, "Result: " + result); return (Object) result; } ', 'UTF8'),localtimestamp,'TooHotThreshold.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Zone Temperature Too Low'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.lang.Math; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import java.util.Date import java.util.HashMap; rule "Too cold threshold" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAvgMap: measuresAvgMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForTooColdThreshold($measuresAvgMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.TOO_COLD_THRESHOLD); $alarmObject.setAlertType(RulesUtil.TOO_COLD_THRESHOLD); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_PERFORMANCE); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.TOO_COLD_THRESHOLD, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForTooColdThreshold(Object measuresObject, Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(measuresObject == null || parametersObject == null || alarmObject == null) { return faultDetected; } String comfortThresholdKeyName = TagConstants.Parameters.COMFORT_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_COLD_THRESHOLD); String durationThresholdKeyName = TagConstants.Parameters.DURATION.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_COLD_THRESHOLD); String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_COLD_THRESHOLD); AlarmObject alarm = (AlarmObject) alarmObject; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; List<String> requiredTags = Arrays.asList(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(), comfortThresholdKeyName, durationThresholdKeyName, severityKeyName); if(!measures.isEmpty() && !parameters.isEmpty()) { List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measures.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areTagsValid(RulesUtil.TOO_COLD_THRESHOLD, tagsToBeChecked, requiredTags)) { GeneralUtil.log(RulesUtil.TOO_COLD_THRESHOLD, GeneralUtil.LEVEL_WARN, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(RulesUtil.TOO_COLD_THRESHOLD, GeneralUtil.LEVEL_WARN, "One or more of these is empty: measures, tags, or parameters"); return faultDetected; } Double comfortThreshold = (Double) parameters.get(comfortThresholdKeyName); Double durationThreshold = (Double) parameters.get(durationThresholdKeyName); /* detect fault */ Map<String, Object> qualifyingFields = (Map<String, Object>) getConditionMetObjectForTooColdThreshold(measuresObject, comfortThreshold, durationThreshold); faultDetected = (boolean) qualifyingFields.get(RulesBaseFact.CONDITION_MET_FIELDNAME); if(faultDetected) { Double actualDuration = (Double) qualifyingFields.get(TagConstants.Parameters.DURATION.getParameterName()); alarm.setSeverity((Double) parameters.get(severityKeyName)); alarm.setDuration(actualDuration); alarm.setTimeOfAlert(qualifyingFields.get(AlarmObject.START_ALERT_FIELDNAME).toString()); alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; } return faultDetected; } function Object getConditionMetObjectForTooColdThreshold(Object measuresObject, Double comfortThreshold, Double durationThreshold) { Double duration = 0.0; String startAlert = null; Map<String, Object> result = new HashMap<>(); result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, false); List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; for(Map<String, Object> currentMeasure : measures) { if(currentMeasure.get(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName()) != null && currentMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()) != null ) { Double currentZoneAirTempSensor = (Double) currentMeasure.get(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName()); GeneralUtil.log(RulesUtil.TOO_COLD_THRESHOLD, GeneralUtil.LEVEL_INFO, "Checking if current measure: " + currentZoneAirTempSensor + " is < comfortThreshold: " + comfortThreshold); if(currentZoneAirTempSensor < comfortThreshold) { duration += 15.0; GeneralUtil.log(RulesUtil.TOO_COLD_THRESHOLD, GeneralUtil.LEVEL_INFO, "Checking if current duration: " + duration + " is >= durationThreshold: " + durationThreshold); if(duration >= durationThreshold) { if(result.get(AlarmObject.START_ALERT_FIELDNAME) == null) { startAlert = currentMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); GeneralUtil.log(RulesUtil.TOO_COLD_THRESHOLD, GeneralUtil.LEVEL_INFO, "Start time of alert: " + startAlert); result.put(AlarmObject.START_ALERT_FIELDNAME, startAlert); } result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, true); result.put(TagConstants.Parameters.DURATION.getParameterName(), duration); } } } } GeneralUtil.log(RulesUtil.TOO_COLD_THRESHOLD, GeneralUtil.LEVEL_INFO, "Result: " + result); return (Object) result; } ', 'UTF8'),localtimestamp,'TooColdThreshold.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Discharge Air Fan Failure'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.lang.Math; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import java.util.HashMap; rule "Proving Fan" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAvgMap: measuresAvgMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForProvingFan($measuresAvgMap, $tagsMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.PROVING_FAN); $alarmObject.setAlertType(RulesUtil.PROVING_FAN); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_EQUIPMENT); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.PROVING_FAN, GeneralUtil.LEVEL_INFO, "Alarm triggered."); retract($data); end function boolean detectFaultForProvingFan(Object measuresObject, Object tagsMapObject, Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(measuresObject == null || tagsMapObject == null || parametersObject == null || alarmObject == null) { GeneralUtil.log(RulesUtil.PROVING_FAN, GeneralUtil.LEVEL_WARN, "null objects."); return faultDetected; } String airFanCmdTagName = TagConstants.Tags.DISCHARGE_AIR_FAN_CMD.getTagName(); String currentThresholdTag = TagConstants.Parameters.CURRENT_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.PROVING_FAN); String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.PROVING_FAN); AlarmObject alarm = (AlarmObject) alarmObject; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; List<Map<String, Object>> tags = (List<Map<String, Object>>) tagsMapObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; List<String> requiredTags = Arrays.asList(TagConstants.Tags.DISCHARGE_AIR_FAN_CURRENT_SENSOR.getTagName(), currentThresholdTag, severityKeyName, airFanCmdTagName); if(!measures.isEmpty() && !tags.isEmpty()) { List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measures.get(0).keySet()); tagsToBeChecked.addAll(tags.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); GeneralUtil.log(RulesUtil.PROVING_FAN, GeneralUtil.LEVEL_INFO, "Tags to be checked: " + tagsToBeChecked); if(!RulesUtil.areTagsValid(RulesUtil.PROVING_FAN, tagsToBeChecked, requiredTags)) { GeneralUtil.log(RulesUtil.PROVING_FAN, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(RulesUtil.PROVING_FAN, GeneralUtil.LEVEL_WARN, "One or more of these is empty: measures, tags, or parameters."); return faultDetected; } /* detect fault here */ Double threshold = (Double) parameters.get(currentThresholdTag); Map<String, Object> qualifyingFields = (Map<String, Object>) getConditionMetObjectForProvingFan(measuresObject, tagsMapObject, threshold); faultDetected = (boolean) qualifyingFields.get(RulesBaseFact.CONDITION_MET_FIELDNAME); if(faultDetected) { Double actualDuration = (Double) qualifyingFields.get(TagConstants.Parameters.DURATION.getParameterName()); alarm.setSeverity((Double) parameters.get(severityKeyName)); alarm.setDuration(actualDuration); if(qualifyingFields.get(AlarmObject.START_ALERT_FIELDNAME) != null) { alarm.setTimeOfAlert(qualifyingFields.get(AlarmObject.START_ALERT_FIELDNAME).toString()); } alarm.setFrequency(AlarmObject.FREQUENCY_15MINUTE); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; } else { GeneralUtil.log(RulesUtil.PROVING_FAN, GeneralUtil.LEVEL_WARN, "Did not meet qualification."); } return faultDetected; } function Object getConditionMetObjectForProvingFan(Object measuresObject, Object tagsMapObject, Double currentThreshold) { Map<String, Object> result = new HashMap<>(); result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, false); Double duration = 0.0; List<Map<String, Object>> tags = (List<Map<String, Object>>) tagsMapObject; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; String currentSensorValueName = TagConstants.Tags.DISCHARGE_AIR_FAN_CURRENT_SENSOR.getTagName(); String eventTsName = TagConstants.Measures.EVENT_TS.getMeasureName(); String airFanCmdTagName = TagConstants.Tags.DISCHARGE_AIR_FAN_CMD.getTagName(); for(int i = 0; i < tags.size() && i < measures.size(); i++) { if(tags.get(i).get(airFanCmdTagName) != null) { if(measures.get(i).get(currentSensorValueName) != null && tags.get(i).get(airFanCmdTagName) != null) { Double currentSensorValue = (Double) measures.get(i).get(currentSensorValueName); String currentStatus = tags.get(i).get(airFanCmdTagName).toString().toLowerCase(); GeneralUtil.log(RulesUtil.PROVING_FAN, GeneralUtil.LEVEL_INFO, "checking currentStatus: " + currentStatus); if(currentStatus.equals("on") || currentStatus.equals("true")) { GeneralUtil.log(RulesUtil.PROVING_FAN, GeneralUtil.LEVEL_INFO, "Checking if currentSensorValue: " + currentSensorValue + " is < currentThreshold: " + currentThreshold); if(currentSensorValue < currentThreshold) { duration += 15; if (tags.get(i).get(eventTsName) != null) { String startAlert = tags.get(i).get(eventTsName).toString(); result.put(AlarmObject.START_ALERT_FIELDNAME, startAlert); } result.put(TagConstants.Parameters.DURATION.getParameterName(), duration); result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, true); } } } } } return (Object) result; } ', 'UTF8'),localtimestamp,'ProvingFan.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Short Cycling'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.lang.Math; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import java.util.HashMap import java.util.Stack; rule "Short Cycling" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForShortCyclingThermostatState($tagsMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE); $alarmObject.setAlertType(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_PERFORMANCE); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForShortCyclingThermostatState( Object tagsMapObject, Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(tagsMapObject == null || parametersObject == null) { return faultDetected; } List<Map<String, Object>> tags = (List<Map<String, Object>>) tagsMapObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; GeneralUtil.log("tags Map object: " + tags + "parametersObject" + parameters); /* for now we are assuming any of the below tags to be available*/ List<String> requiredAnyTags = Arrays.asList(TagConstants.Tags.AHU_COOL_STAGE_1.getTagName(), TagConstants.Tags.AHU_HEAT_STAGE_1.getTagName(), TagConstants.Tags.RTU_COOL_STAGE1.getTagName(), TagConstants.Tags.RTU_HEAT_STAGE1.getTagName()); List<String> requiredParameters = Arrays.asList(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE)); if(!tags.isEmpty() && !parameters.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); List<String> parametersToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(tags.get(0).keySet()); parametersToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areAnyTagsValid(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, tagsToBeChecked, requiredAnyTags)) { GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } if(!RulesUtil.areTagsValid(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, parametersToBeChecked, requiredParameters)) { GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_WARN, "One or more of these is empty: tags, or parameters"); return faultDetected; } Map<String, Object> results = (Map<String, Object>) getShortCyclingThermostatStateResult(tagsMapObject, parametersObject); faultDetected = (boolean) results.get("detectFault"); if(!faultDetected) { return faultDetected; } String startAlertTime = (String) results.get("startAlert"); Double duration = (Double) results.get("duration"); AlarmObject alarm = (AlarmObject) alarmObject; String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE); if (parameters.get(severityKeyName) != null) { alarm.setSeverity((Double) parameters.get(severityKeyName)); } alarm.setDuration(duration); alarm.setTimeOfAlert(startAlertTime); alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_NORM_LOG); alarmObject = alarm; return faultDetected; } /* getting the number of on off cycles for each tag considered */ function Map<String, Integer> getNumOfOnOffCycles(Object onOfMapObject){ Map<String, List<String>> onOfCyclesMap = (Map<String, List<String>>) onOfMapObject; Map<String, Integer> onOfCycleCounts = new HashMap<>(); List<List<String>> cycleList = getPossibleCyclesShortCyclingThermostatState(); for(String cmdKey: onOfCyclesMap.keySet()){ List<String> cmdList = onOfCyclesMap.get(cmdKey); int cycleCount = 0; for(int i = TagConstants.ON_OFF_WINDOW_LENGTH-1; i < cmdList.size(); i++ ){ List<String> cmdSubList = cmdList.subList(i-(TagConstants.ON_OFF_WINDOW_LENGTH - 1),i +1); GeneralUtil.log(" ******* cmd key ****** " + cmdKey + " ******* Cmd List = " + cmdList + " ******* " +cmdSubList); boolean cycleDetected = cycleList.stream().anyMatch(cycle -> cycle.equals(cmdSubList)); if (cycleDetected) cycleCount++; } onOfCycleCounts.put(cmdKey, cycleCount); } return onOfCycleCounts; } /* detecting if a given list of commands is a cycle */ function Boolean detectCycle(Object cmdSubList){ /* possible cycle combinations of */ List<String> cmdSublit = (List<String>) cmdSubList; List<List<String>> cycleList = getPossibleCyclesShortCyclingThermostatState(); boolean cycleDetected = cycleList.stream().anyMatch(cycle -> cycle.equals(cmdSublit)); return cycleDetected; } /* Getting possible cycle lists */ function List<List<String>> getPossibleCyclesShortCyclingThermostatState(){ List<List<String>> cycleList = new ArrayList<List<String>>(); List<String> cycle1 = Arrays.asList(TagConstants.ON_COMMAND_STATUS, TagConstants.OFF_COMMAND_STATUS, TagConstants.ON_COMMAND_STATUS); List<String> cycle2 = Arrays.asList(TagConstants.OFF_COMMAND_STATUS, TagConstants.ON_COMMAND_STATUS, TagConstants.OFF_COMMAND_STATUS); cycleList.add(cycle1); cycleList.add(cycle2); return cycleList; } function Object getShortCyclingThermostatStateResult(Object tagsMapObject, Object parametersObject){ Map<String, Object> result = new HashMap<>(); String startAlert = null; boolean detectFault = false; List<Map<String, Object>> tags = (List<Map<String, Object>>) tagsMapObject; Double duration = 0.0; Map<String, Object> parameters = (Map<String, Object>) parametersObject; String userThresholdStr = "user_Threshold" + RulesUtil.getFDSINumber(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE); double userThreshold = (Double) parameters.get(userThresholdStr); List<String> requiredAnyTags = Arrays.asList(TagConstants.Tags.RTU_COOL_STAGE1.getTagName(), TagConstants.Tags.RTU_HEAT_STAGE1.getTagName(), TagConstants.Tags.AHU_COOL_STAGE_1.getTagName(), TagConstants.Tags.AHU_HEAT_STAGE_1.getTagName()); List<String> tagsNeeded = new ArrayList<>(tags.get(0).keySet()); List<String> tagsForOnOffCycle = RulesUtil.getNeededTagsFromTags(tagsNeeded, requiredAnyTags); Map<String, List<String>> onOfCyclesMap = new HashMap<>(); for (Map<String, Object> currentTag: tags){ for(String cmd: tagsForOnOffCycle){ String cmdStatus = (String) currentTag.get(cmd); List<String> updatedOnOffList = new ArrayList<>(); if (!onOfCyclesMap.isEmpty() && onOfCyclesMap.containsKey(cmd)){ updatedOnOffList = (List<String>) onOfCyclesMap.get(cmd); updatedOnOffList.add(cmdStatus); } else { updatedOnOffList.add(cmdStatus); } onOfCyclesMap.put(cmd, updatedOnOffList); } Map<String, Integer> onOffCycleCounts = getNumOfOnOffCycles((Object) onOfCyclesMap); int sumOnOffCyles = onOffCycleCounts.values().stream().mapToInt(Integer::intValue).sum(); if (sumOnOffCyles > userThreshold){ duration += 5; detectFault = true; if(startAlert == null){ startAlert = currentTag.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); } } } result.put("detectFault", detectFault); result.put("startAlert", startAlert); result.put("duration", duration); GeneralUtil.log(RulesUtil.SHORT_CYCLING_THERMOSTAT_STATE, GeneralUtil.LEVEL_INFO, "duration: " + duration + " userThreshold " + userThreshold + "Start Alert time" + startAlert); return (Object) result; } ', 'UTF8'),localtimestamp,'ShortCyclingThermostatState.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Excessive HVAC Overrides'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.lang.Math; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import java.util.HashMap rule "Excessive HVAC Overrides" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $measuresAggrMap: measuresAggrMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForExcessiveHVACOverridesCount($measuresAggrMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_COUNT); $alarmObject.setAlertType(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_COUNT); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_VIOLATION); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_COUNT, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForExcessiveHVACOverridesCount(Object measuresAggObject , Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(measuresAggObject == null || parametersObject == null) { return faultDetected; } List<Map<String, Object>> measuresAgg = (List<Map<String, Object>>) measuresAggObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; String hvacStateOverrideTagName = TagConstants.Tags.HVAC_STATE_OVERRIDE.getTagName(); String excessiveHvacOverridesCount = RulesUtil.EXCESSIVE_HVAC_OVERRIDES_COUNT; List<String> requiredTags = Arrays.asList(hvacStateOverrideTagName, TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveHvacOverridesCount)); if(!measuresAgg.isEmpty() && !parameters.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measuresAgg.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areTagsValid(excessiveHvacOverridesCount, tagsToBeChecked, requiredTags)) { GeneralUtil.log(excessiveHvacOverridesCount, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(excessiveHvacOverridesCount, GeneralUtil.LEVEL_WARN, "One or more of these is empty: measures, tags, or parameters"); return faultDetected; } if(parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveHvacOverridesCount)) == null){ GeneralUtil.log(excessiveHvacOverridesCount, GeneralUtil.LEVEL_INFO," userThreshold is null"); return faultDetected; } Double userThreshold = (Double) parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveHvacOverridesCount)); Map<String, Object> results = (Map<String, Object>) getResultHvacStateOverrideCounts(measuresAggObject, (Object) userThreshold); faultDetected = (boolean) results.get("detectFault"); if(!faultDetected) { return faultDetected; } String startAlertTime = (String) results.get("startAlert"); Double duration = (Double) results.get("duration"); AlarmObject alarm = (AlarmObject) alarmObject; String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(excessiveHvacOverridesCount); if (parameters.get(severityKeyName) != null) { alarm.setSeverity((Double) parameters.get(severityKeyName)); } alarm.setDuration(duration); alarm.setTimeOfAlert(startAlertTime); alarm.setFrequency(AlarmObject.FREQUENCY_DAILY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; return faultDetected; } function Object getResultHvacStateOverrideCounts(Object measuresAggMapObject, Object threshold){ Map<String, Object> result = new HashMap<>(); String startAlert = null; boolean detectFault = false; double timeThreshold = (double) threshold; List<Map<String, Object>> measuresAggMap = (List<Map<String, Object>>) measuresAggMapObject; String hvacStateOverrideCount = TagConstants.Tags.HVAC_STATE_OVERRIDE.getTagName(); Double totalHvacStateOverrideCounts = 0.0; Double sumHvacStateOverrideCountsTime = 0.0; for (Map<String, Object> currentMeasuresMap: measuresAggMap){ if (currentMeasuresMap.get(hvacStateOverrideCount) != null){ totalHvacStateOverrideCounts += (Double) currentMeasuresMap.get(hvacStateOverrideCount); if (totalHvacStateOverrideCounts > timeThreshold){ sumHvacStateOverrideCountsTime += 15.0; detectFault = true; if(startAlert == null){ startAlert = currentMeasuresMap.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); } } } } result.put("detectFault", detectFault); result.put("startAlert", startAlert); result.put("duration", sumHvacStateOverrideCountsTime); GeneralUtil.log(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_COUNT, GeneralUtil.LEVEL_INFO, "sumHvacStateOverrideTimeCounts: " + sumHvacStateOverrideCountsTime + " userThreshold " + timeThreshold + "Start Alert time" + startAlert); return (Object) result; } ', 'UTF8'),localtimestamp,'ExcessiveHVACOverridesCount.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Excessive Lighting Overrides'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.lang.Math; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import java.util.HashMap rule "Excessive Lighting Overrides" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $measuresAggrMap: measuresAggrMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForExcessiveLightingOverridesCount($measuresAggrMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.EXCESSIVE_LIGHTING_OVERRIDES_COUNT); $alarmObject.setAlertType(RulesUtil.EXCESSIVE_LIGHTING_OVERRIDES_COUNT); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_VIOLATION); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.EXCESSIVE_LIGHTING_OVERRIDES_COUNT, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForExcessiveLightingOverridesCount(Object measuresAggrMapObj, Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(measuresAggrMapObj == null || parametersObject == null) { return faultDetected; } List<Map<String, Object>> measuresAgg = (List<Map<String, Object>>) measuresAggrMapObj; Map<String, Object> parameters = (Map<String, Object>) parametersObject; String lightingStateOverrideTagName = TagConstants.Tags.LIGHTING_STATE_OVERRIDE.getTagName(); String excessiveLightingOverridesCount = RulesUtil.EXCESSIVE_LIGHTING_OVERRIDES_COUNT; List<String> requiredTags = Arrays.asList(lightingStateOverrideTagName, TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveLightingOverridesCount)); if(!measuresAgg.isEmpty() && !parameters.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measuresAgg.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areTagsValid(excessiveLightingOverridesCount, tagsToBeChecked, requiredTags)) { GeneralUtil.log(excessiveLightingOverridesCount, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(excessiveLightingOverridesCount, GeneralUtil.LEVEL_WARN, "One or more of these is empty: measuresAgg, or parameters"); return faultDetected; } Object userThr = parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveLightingOverridesCount)); if(userThr == null){ GeneralUtil.log(excessiveLightingOverridesCount, GeneralUtil.LEVEL_INFO, "userThreshold is null"); return faultDetected; } Double userThreshold = (Double) parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveLightingOverridesCount)); Map<String, Object> results = (Map<String, Object>) getResultLightingStateOverrideCounts(measuresAggrMapObj, (Object) userThreshold); faultDetected = (boolean) results.get("detectFault"); if(!faultDetected) { return faultDetected; } String startAlertTime = (String) results.get("startAlert"); Double duration = (Double) results.get("duration"); AlarmObject alarm = (AlarmObject) alarmObject; String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(excessiveLightingOverridesCount); if (parameters.get(severityKeyName) != null) { alarm.setSeverity((Double) parameters.get(severityKeyName)); } alarm.setDuration(duration); alarm.setTimeOfAlert(startAlertTime); alarm.setFrequency(AlarmObject.FREQUENCY_DAILY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; return faultDetected; } function Double getLightingStateOverrideCounts(Object tagsObject){ List<Map<String, Object>> tags = (List<Map<String, Object>>) tagsObject; String lightingStateOverrideTagName = TagConstants.Tags.LIGHTING_STATE_OVERRIDE.getTagName(); Double totalLightingStateOverrideCounts = (Double) tags.stream().filter( m -> m.get(lightingStateOverrideTagName) != null). mapToDouble(s -> (Double) s.get(lightingStateOverrideTagName)).sum(); return totalLightingStateOverrideCounts; } function Object getResultLightingStateOverrideCounts(Object measuresAggMapObject, Object threshold){ Map<String, Object> result = new HashMap<>(); String startAlert = null; boolean detectFault = false; double timeThreshold = (double) threshold; List<Map<String, Object>> measuresAgg = (List<Map<String, Object>>) measuresAggMapObject; String lightingStateOverrideTagName = TagConstants.Tags.LIGHTING_STATE_OVERRIDE.getTagName(); Double totalLightingStateOverrideCounts = 0.0; Double sumLightingStateOverrideCountsTime = 0.0; for (Map<String, Object> currentMeasuresMap: measuresAgg){ if (currentMeasuresMap.get(lightingStateOverrideTagName) != null){ totalLightingStateOverrideCounts += (Double) currentMeasuresMap.get(lightingStateOverrideTagName); if (totalLightingStateOverrideCounts > timeThreshold){ sumLightingStateOverrideCountsTime += 15.0; detectFault = true; if(startAlert == null){ startAlert = currentMeasuresMap.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); } } } } result.put("detectFault", detectFault); result.put("startAlert", startAlert); result.put("duration", sumLightingStateOverrideCountsTime); GeneralUtil.log(RulesUtil.EXCESSIVE_LIGHTING_OVERRIDES_COUNT, GeneralUtil.LEVEL_INFO, "sumLightingStateOverrideCountsTime: " + sumLightingStateOverrideCountsTime + " userThreshold " + timeThreshold + "Start Alert time" + startAlert); return (Object) result; } ', 'UTF8'),localtimestamp,'ExcessiveLightingOverridesCount.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Excessive HVAC Overrides Runtime'),'DRL',convert_to('package com.ge.current.em.rules; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import java.util.HashMap rule "Excessive HVAC Overrides Runtime" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAggrMap: measuresAggrMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForExcessiveHVACOverridesTime($measuresAggrMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_TIME); $alarmObject.setAlertType(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_TIME); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_VIOLATION); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_TIME, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForExcessiveHVACOverridesTime(Object measuresMapObject, Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(measuresMapObject == null || parametersObject == null) { return faultDetected; } List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresMapObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; String hvacStateOverrideTrueRuntimeTagName = TagConstants.Tags.HVAC_STATE_OVERRIDE_TRUE_RUNTIME.getTagName(); String excessiveHVACUsageAfterHoursRuleName = RulesUtil.EXCESSIVE_HVAC_USAGE_AFTER_HOURS; List<String> requiredTags = Arrays.asList(hvacStateOverrideTrueRuntimeTagName, TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_TIME)); if(!measures.isEmpty() && !parameters.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measures.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areTagsValid(excessiveHVACUsageAfterHoursRuleName, tagsToBeChecked, requiredTags)) { GeneralUtil.log(excessiveHVACUsageAfterHoursRuleName, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(excessiveHVACUsageAfterHoursRuleName, GeneralUtil.LEVEL_WARN, "One or more of these is empty: measures, tags, or parameters"); return faultDetected; } Object userThr = parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_TIME)); if(userThr == null){ GeneralUtil.log(excessiveHVACUsageAfterHoursRuleName, GeneralUtil.LEVEL_INFO, "userThreshold is null"); return faultDetected; } Double userThreshold = (Double) parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_TIME)); Map<String, Object> results = (Map<String, Object>) getResultHvacStateOverrideTime(measuresMapObject, (Object) userThreshold); faultDetected = (boolean) results.get("detectFault"); if(!faultDetected) { return faultDetected; } String startAlertTime = (String) results.get("startAlert"); Double duration = (Double) results.get("duration"); AlarmObject alarm = (AlarmObject) alarmObject; String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_TIME); if (parameters.get(severityKeyName) != null) { alarm.setSeverity((Double) parameters.get(severityKeyName)); } alarm.setDuration(duration); alarm.setTimeOfAlert(startAlertTime); alarm.setFrequency(AlarmObject.FREQUENCY_DAILY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; return faultDetected; } function Object getResultHvacStateOverrideTime(Object measuresMapObject, Object threshold){ Map<String, Object> result = new HashMap<>(); String startAlert = null; boolean detectFault = false; double timeThreshold = (double) threshold; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresMapObject; String hvacStateOverrideTrueRuntimeTagName = TagConstants.Tags.HVAC_STATE_OVERRIDE_TRUE_RUNTIME.getTagName(); Double sumHvacStateOverrideTime = 0.0; for (Map<String, Object> currentMapMeasure: measures){ if (currentMapMeasure.get(hvacStateOverrideTrueRuntimeTagName) != null){ sumHvacStateOverrideTime += (Double) currentMapMeasure.get(hvacStateOverrideTrueRuntimeTagName); if (sumHvacStateOverrideTime > timeThreshold){ detectFault = true; if(startAlert == null){ startAlert = currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); } } } } result.put("detectFault", detectFault); result.put("startAlert", startAlert); result.put("duration", sumHvacStateOverrideTime); GeneralUtil.log(RulesUtil.EXCESSIVE_HVAC_OVERRIDES_TIME, GeneralUtil.LEVEL_INFO, "sumHvacStateOverrideTime: " + sumHvacStateOverrideTime + " userThreshold " + timeThreshold + "Start Alert time" + startAlert); return (Object) result; } ', 'UTF8'),localtimestamp,'ExcessiveHVACOverridesTime.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Zone Cooling Delta T Too High'),'DRL',convert_to('package com.ge.current.em.rules; import java.io.Serializable; import java.util.List; import java.util.Arrays; import java.util.Map; import java.lang.Double; import java.lang.Math; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil; import java.util.ArrayList import java.util.HashMap; rule "Zone Cooling Delta T Too High" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAvgMap: measuresAvgMap, $measuresAggrMap: measuresAggrMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForCoolingDoesNotWork($measuresAvgMap,$measuresAggrMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.COOLING_DOES_NOT_WORK); $alarmObject.setAlertType(RulesUtil.COOLING_DOES_NOT_WORK); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_EQUIPMENT); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.COOLING_DOES_NOT_WORK, GeneralUtil.LEVEL_INFO, "Alarm triggered."); retract($data); end function boolean detectFaultForCoolingDoesNotWork(Object measuresAvgObject,Object measuresAggrObject, Object parametersObject, Object alarmObject) { String coolingDoesNotWorkRuleName = RulesUtil.COOLING_DOES_NOT_WORK; String minITDKeyName = TagConstants.Parameters.MIN_ITD.getParameterName() + RulesUtil.getFDSINumber(coolingDoesNotWorkRuleName); String runtimeThresholdName = TagConstants.Parameters.RUNTIME_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(coolingDoesNotWorkRuleName); boolean faultDetected = false; if(measuresAvgObject == null || measuresAggrObject ==null || parametersObject == null) { return faultDetected; } List<Map<String, Object>> measuresAvg = (List<Map<String, Object>>) measuresAvgObject; List<Map<String, Object>> measuresAggr = (List<Map<String, Object>>) measuresAggrObject; String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.COOLING_DOES_NOT_WORK); Map<String,Object> parameters = (Map<String,Object>) parametersObject; String ahuCoolStage1OnRunTime = TagConstants.Tags.AHU_COOL_STAGE_1_ON_RUNTIME.getTagName(); String rtuCoolStage1OnRunTime = TagConstants.Tags.RTU_COOL_STAGE_1_ON_RUNTIME.getTagName(); List<String> requiredTags = Arrays.asList(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(), minITDKeyName, TagConstants.Tags.DISCHARGE_AIR_TEMP_SENSOR.getTagName()); List<String> requiredAnyTags = Arrays.asList(ahuCoolStage1OnRunTime, rtuCoolStage1OnRunTime); if(!measuresAvg.isEmpty() && !parameters.isEmpty() && !measuresAggr.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measuresAvg.get(0).keySet()); tagsToBeChecked.addAll(measuresAggr.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areAnyTagsValid(coolingDoesNotWorkRuleName, tagsToBeChecked, requiredAnyTags)){ return faultDetected; } if(!RulesUtil.areTagsValid(coolingDoesNotWorkRuleName, tagsToBeChecked, requiredTags)) { return faultDetected; } } if(parameters.get(minITDKeyName) == null || parameters.get(runtimeThresholdName) == null){ GeneralUtil.log(coolingDoesNotWorkRuleName, GeneralUtil.LEVEL_INFO," parameters.get(minITDKeyName) or parameters.get(runtimeThresholdName) is null"); return faultDetected; } Double minITD = (Double) parameters.get(minITDKeyName); Double runtimeThresholdValue = (Double) parameters.get(runtimeThresholdName); GeneralUtil.log(coolingDoesNotWorkRuleName, GeneralUtil.LEVEL_INFO, "Zone Cooling Delta T Too High, minITD:" + minITD + " runtimeThresholdValue: " + runtimeThresholdValue); /* checking condition met*/ if(getTotalCoolStage1OnRuntime(measuresAggrObject, (Object) ahuCoolStage1OnRunTime) < runtimeThresholdValue && getTotalCoolStage1OnRuntime(measuresAggrObject, (Object) rtuCoolStage1OnRunTime) < runtimeThresholdValue ){ GeneralUtil.log(coolingDoesNotWorkRuleName, GeneralUtil.LEVEL_WARN, "Condition is not met"); return faultDetected; } Map<String, Object> results = (Map<String, Object>) getConditionMetObjectCoolingDoesNotWork(measuresAvgObject, (Object) minITD); faultDetected = (boolean) results.get("detectFault"); if(!faultDetected) { return faultDetected; } String startAlertTime = (String) results.get("startAlert"); Double duration = (Double) results.get("duration"); AlarmObject alarm = (AlarmObject) alarmObject; alarm.setDuration(duration); alarm.setTimeOfAlert(startAlertTime); alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); if (parameters.get(severityKeyName) != null) { alarm.setSeverity((Double) parameters.get(severityKeyName)); } alarmObject = alarm; return faultDetected; } /* getting the total runtime for eacht tag considered*/ function Double getTotalCoolStage1OnRuntime(Object measuresAggrMapObject, Object hvacStatusOnRuntimeTagName){ List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresAggrMapObject; String hvacStatusOnRuntimeTag = (String) hvacStatusOnRuntimeTagName; Double hvacStatusOnRuntimeSum = measures.stream().filter(m -> m.get(hvacStatusOnRuntimeTag) != null) .mapToDouble(s -> (Double) s.get(hvacStatusOnRuntimeTag)).sum(); GeneralUtil.log("hvacStatusOnRuntimeTag" + hvacStatusOnRuntimeSum); return hvacStatusOnRuntimeSum; } function Object getConditionMetObjectCoolingDoesNotWork(Object measuresAvgMapObject, Object minItdValue){ Map<String, Object> result = new HashMap<>(); String startAlert = null; boolean detectFault = false; double minItd = (double) minItdValue; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresAvgMapObject; String zoneAirTempSensor = TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(); String dischargeAirTempSensor = TagConstants.Tags.DISCHARGE_AIR_TEMP_SENSOR.getTagName(); Double duration = 0.0; for (Map<String, Object> currentMapMeasure: measures){ if (currentMapMeasure.get(zoneAirTempSensor) != null && currentMapMeasure.get(dischargeAirTempSensor) != null){ Double itd = (Double) currentMapMeasure.get(zoneAirTempSensor) - (Double) currentMapMeasure.get(dischargeAirTempSensor); if (itd > minItd) { detectFault = true; if (currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()) != null && startAlert == null) { startAlert = currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); } duration += 15.00; } } } result.put("detectFault", detectFault); result.put("startAlert", startAlert); result.put("duration", duration); GeneralUtil.log(RulesUtil.COOLING_DOES_NOT_WORK, GeneralUtil.LEVEL_INFO, "detectFault: " + detectFault + " duration: " + duration + " minItd: " + minItd + " Start Alert time: " + startAlert); return (Object) result; } ', 'UTF8'),localtimestamp,'CoolingDoesNotWork.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Zone Heating Delta T Too High'),'DRL',convert_to('package com.ge.current.em.rules; import java.io.Serializable; import java.util.List; import java.util.Arrays; import java.util.Map; import java.lang.Double; import java.lang.Math; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil; import java.util.ArrayList import java.util.HashMap; rule "Zone Heating Delta T Too High" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAvgMap: measuresAvgMap, $measuresAggrMap: measuresAggrMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForHeatingDoesNotWork($measuresAvgMap,$measuresAggrMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.HEATING_DOES_NOT_WORK); $alarmObject.setAlertType(RulesUtil.HEATING_DOES_NOT_WORK); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_EQUIPMENT); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.HEATING_DOES_NOT_WORK, GeneralUtil.LEVEL_INFO, "Alarm triggered."); retract($data); end function boolean detectFaultForHeatingDoesNotWork(Object measuresAvgObject,Object measuresAggrObject, Object parametersObject, Object alarmObject) { String heatingDoesNotWorkRuleName = RulesUtil.HEATING_DOES_NOT_WORK; String minITDKeyName = TagConstants.Parameters.MIN_ITD.getParameterName() + RulesUtil.getFDSINumber(heatingDoesNotWorkRuleName); String runtimeThresholdName = TagConstants.Parameters.RUNTIME_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(heatingDoesNotWorkRuleName); boolean faultDetected = false; if(measuresAvgObject == null || measuresAggrObject ==null || parametersObject == null) { return faultDetected; } List<Map<String, Object>> measuresAvg = (List<Map<String, Object>>) measuresAvgObject; List<Map<String, Object>> measuresAggr = (List<Map<String, Object>>) measuresAggrObject; Map<String,Object> parameters = (Map<String,Object>) parametersObject; String ahuHeatStage1OnRunTime = TagConstants.Tags.AHU_HEAT_STAGE_1_ON_RUNTIME.getTagName(); String rtuHeatStage1OnRunTime = TagConstants.Tags.RTU_HEAT_STAGE_1_ON_RUNTIME.getTagName(); List<String> requiredTags = Arrays.asList(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(), minITDKeyName, TagConstants.Tags.DISCHARGE_AIR_TEMP_SENSOR.getTagName()); List<String> requiredAnyTags = Arrays.asList(ahuHeatStage1OnRunTime, rtuHeatStage1OnRunTime); if(!measuresAvg.isEmpty() && !parameters.isEmpty() && !measuresAggr.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measuresAvg.get(0).keySet()); tagsToBeChecked.addAll(measuresAggr.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areAnyTagsValid(heatingDoesNotWorkRuleName, tagsToBeChecked, requiredAnyTags)){ return faultDetected; } if(!RulesUtil.areTagsValid(heatingDoesNotWorkRuleName, tagsToBeChecked, requiredTags)) { GeneralUtil.log(heatingDoesNotWorkRuleName, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } if(parameters.get(minITDKeyName) == null || parameters.get(runtimeThresholdName) == null){ GeneralUtil.log(heatingDoesNotWorkRuleName, GeneralUtil.LEVEL_INFO," parameters.get(minITDKeyName) or parameters.get(runtimeThresholdName) is null"); return faultDetected; } Double minITD = (Double) parameters.get(minITDKeyName); Double runtimeThresholdValue = (Double) parameters.get(runtimeThresholdName); String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.HEATING_DOES_NOT_WORK); GeneralUtil.log(heatingDoesNotWorkRuleName, GeneralUtil.LEVEL_INFO, "Zone Heating Delta T Too High, runtimeThresholdValue: " + runtimeThresholdValue); /* checking condition met*/ if(getTotalHeatStage1OnRuntime(measuresAggrObject, (Object) ahuHeatStage1OnRunTime) < runtimeThresholdValue && getTotalHeatStage1OnRuntime(measuresAggrObject, (Object) rtuHeatStage1OnRunTime) < runtimeThresholdValue ){ GeneralUtil.log(heatingDoesNotWorkRuleName, GeneralUtil.LEVEL_WARN, "Condition is not met"); return faultDetected; } Map<String, Object> results = (Map<String, Object>) getResultHeatingDoesNotWork(measuresAvgObject, (Object) minITD); faultDetected = (boolean) results.get("detectFault"); if(!faultDetected) { return faultDetected; } String startAlertTime = (String) results.get("startAlert"); Double duration = (Double) results.get("duration"); AlarmObject alarm = (AlarmObject) alarmObject; alarm.setSeverity((Double) parameters.get(TagConstants.Parameters.SEVERITY.getParameterName())); alarm.setDuration(duration); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarm.setTimeOfAlert(startAlertTime); if (parameters.get(severityKeyName) != null) { alarm.setSeverity((Double) parameters.get(severityKeyName)); } alarmObject = alarm; return faultDetected; } /* getting the total runtime for eacht tag considered*/ function Double getTotalHeatStage1OnRuntime(Object measuresAggrMapObject, Object hvacStatusOnRuntimeTagName){ List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresAggrMapObject; String hvacStatusOnRuntimeTag = (String) hvacStatusOnRuntimeTagName; Double hvacStatusOnRuntimeSum = measures.stream().filter(m -> m.get(hvacStatusOnRuntimeTag) != null) .mapToDouble(s -> (Double) s.get(hvacStatusOnRuntimeTag)).sum(); return hvacStatusOnRuntimeSum; } function Object getResultHeatingDoesNotWork(Object measuresAvgMapObject, Object minItdValue){ Map<String, Object> result = new HashMap<>(); String startAlert = null; boolean detectFault = false; double minItd = (double) minItdValue; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresAvgMapObject; String zoneAirTempSensor = TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(); String dischargeAirTempSensor = TagConstants.Tags.DISCHARGE_AIR_TEMP_SENSOR.getTagName(); Double duration = 0.0; for (Map<String, Object> currentMapMeasure: measures){ if (currentMapMeasure.get(dischargeAirTempSensor) != null && currentMapMeasure.get(zoneAirTempSensor) != null){ Double itd = (Double) currentMapMeasure.get(dischargeAirTempSensor) - (Double) currentMapMeasure.get(zoneAirTempSensor); if (itd > minItd){ detectFault = true; if (currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()) != null && startAlert == null) { startAlert = currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); } duration += 15.00; } } } result.put("detectFault", detectFault); result.put("startAlert", startAlert); result.put("duration", duration); GeneralUtil.log(RulesUtil.HEATING_DOES_NOT_WORK, GeneralUtil.LEVEL_INFO,"detectFault: " + detectFault + " duration: " + duration + " minItd: " + minItd + " Start Alert time: " + startAlert); return (Object) result; } ', 'UTF8'),localtimestamp,'HeatingDoesNotWork.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Zone Cooling Setpoint Unreachable'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import com.ge.current.em.util.TagConstants import java.util.HashMap; rule "Too Hot - Setpoint" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAvgMap: measuresAvgMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForTooHotSetpoint($measuresAvgMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.TOO_HOT_SETPOINT); $alarmObject.setAlertType(RulesUtil.TOO_HOT_SETPOINT); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_PERFORMANCE); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.TOO_HOT_SETPOINT, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForTooHotSetpoint(Object measuresObject, Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(measuresObject == null || parametersObject == null || alarmObject == null) { return faultDetected; } AlarmObject alarm = (AlarmObject) alarmObject; String setpointOffsetKeyName = TagConstants.Parameters.SETPOINT_OFFSET.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_HOT_SETPOINT); String durationThresholdKeyName = TagConstants.Parameters.DURATION.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_HOT_SETPOINT); String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_HOT_SETPOINT); List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; List<String> requiredTags = Arrays.asList(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(), /* we look at cooling here*/ TagConstants.Tags.ZONE_AIR_TEMP_EFFECTIVE_SP_COOLING.getTagName(), setpointOffsetKeyName, durationThresholdKeyName, severityKeyName); if(!measures.isEmpty() && !parameters.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measures.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areTagsValid(RulesUtil.TOO_HOT_SETPOINT, tagsToBeChecked, requiredTags)) { GeneralUtil.log(RulesUtil.TOO_HOT_SETPOINT, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(RulesUtil.TOO_HOT_SETPOINT, GeneralUtil.LEVEL_WARN, "measures and/or parameters is empty"); return faultDetected; } Double setpointOffset = (Double) parameters.get(setpointOffsetKeyName); Double durationThreshold = (Double) parameters.get(durationThresholdKeyName); /* detect fault */ Map<String, Object> qualifyingFields = (Map<String, Object>) getQualifyingFieldsForTooHotSetpoint(measuresObject, setpointOffset, durationThreshold); faultDetected = (boolean) qualifyingFields.get(RulesBaseFact.CONDITION_MET_FIELDNAME); if(faultDetected) { Double actualDuration = (Double) qualifyingFields.get(TagConstants.Parameters.DURATION.getParameterName()); alarm.setSeverity((Double) parameters.get(severityKeyName)); alarm.setDuration(actualDuration); alarm.setTimeOfAlert(qualifyingFields.get(AlarmObject.START_ALERT_FIELDNAME).toString()); alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; } return faultDetected; } function Object getQualifyingFieldsForTooHotSetpoint(Object measuresObject, Double setpointOffset, Double durationThreshold) { Double duration = 0.0; String startAlert = null; Map<String, Object> result = new HashMap<>(); result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, false); List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; String zoneAirTempSensorName = TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(); String zoneAirTempCoolingSpName = TagConstants.Tags.ZONE_AIR_TEMP_EFFECTIVE_SP_COOLING.getTagName(); String eventTsName = TagConstants.Measures.EVENT_TS.getMeasureName(); for(Map<String, Object> currentMeasure : measures) { if (currentMeasure.get(zoneAirTempSensorName) != null && currentMeasure.get(zoneAirTempCoolingSpName) != null && currentMeasure.get(eventTsName) != null) { Double currentTempSensor = (Double) currentMeasure.get(zoneAirTempSensorName); Double currentEffectiveSp = (Double) currentMeasure.get(zoneAirTempCoolingSpName); String eventTs = currentMeasure.get(eventTsName).toString(); GeneralUtil.log(RulesUtil.TOO_HOT_SETPOINT, GeneralUtil.LEVEL_INFO, "Comparing if currentZoneAirTempSensor: " + currentTempSensor + " is > currentCoolingSp: " + currentEffectiveSp + " + setpointOffset: " + setpointOffset); if ( currentTempSensor > currentEffectiveSp + setpointOffset) { duration += 15.0; GeneralUtil.log(RulesUtil.TOO_HOT_SETPOINT, GeneralUtil.LEVEL_INFO, "Checking if current duration: " + duration + " is >= durationThreshold: " + durationThreshold); if (duration >= durationThreshold) { if(result.get(AlarmObject.START_ALERT_FIELDNAME) == null) { startAlert = eventTs; GeneralUtil.log(RulesUtil.TOO_HOT_SETPOINT, GeneralUtil.LEVEL_INFO, "Start time of alert: " + startAlert); result.put(AlarmObject.START_ALERT_FIELDNAME, startAlert); } result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, true); result.put(TagConstants.Parameters.DURATION.getParameterName(), duration); } } } } return (Object) result; } ', 'UTF8'),localtimestamp,'TooHotSetpoint.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Zone Heating Setpoint Unreachable'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import com.ge.current.em.util.TagConstants import java.util.HashMap rule "Too Cold - Setpoint" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAvgMap: measuresAvgMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForTooColdSetpoint($measuresAvgMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.TOO_COLD_SETPOINT); $alarmObject.setAlertType(RulesUtil.TOO_COLD_SETPOINT); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_PERFORMANCE); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.TOO_COLD_SETPOINT, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForTooColdSetpoint(Object measuresObject, Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(measuresObject == null || parametersObject == null || alarmObject == null) { return faultDetected; } AlarmObject alarm = (AlarmObject) alarmObject; String setpointOffsetKeyName = TagConstants.Parameters.SETPOINT_OFFSET.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_COLD_SETPOINT); String durationThresholdKeyName = TagConstants.Parameters.DURATION.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_COLD_SETPOINT); String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.TOO_COLD_SETPOINT); List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; List<String> requiredTags = Arrays.asList(TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(), /* we use heating here */ TagConstants.Tags.ZONE_AIR_TEMP_EFFECTIVE_SP_HEATING.getTagName(), setpointOffsetKeyName, durationThresholdKeyName, severityKeyName); if(!measures.isEmpty() && !parameters.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measures.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areTagsValid(RulesUtil.TOO_COLD_SETPOINT, tagsToBeChecked, requiredTags)) { GeneralUtil.log(RulesUtil.TOO_COLD_SETPOINT, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(RulesUtil.TOO_COLD_SETPOINT, GeneralUtil.LEVEL_WARN, "measures and/or parameters is empty"); return faultDetected; } Double setpointOffset = (Double) parameters.get(setpointOffsetKeyName); Double durationThreshold = (Double) parameters.get(durationThresholdKeyName); /* detect fault */ Map<String, Object> qualifyingFields = (Map<String, Object>) getConditionMetObjectForTooColdSetpoint(measuresObject, setpointOffset, durationThreshold); faultDetected = (boolean) qualifyingFields.get(RulesBaseFact.CONDITION_MET_FIELDNAME); if(faultDetected) { Double actualDuration = (Double) qualifyingFields.get(TagConstants.Parameters.DURATION.getParameterName()); alarm.setSeverity((Double) parameters.get(severityKeyName)); alarm.setDuration(actualDuration); alarm.setTimeOfAlert(qualifyingFields.get(AlarmObject.START_ALERT_FIELDNAME).toString()); alarm.setFrequency(AlarmObject.FREQUENCY_HOURLY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; } return faultDetected; } function Object getConditionMetObjectForTooColdSetpoint(Object measuresObject, Double setpointOffset, Double durationThreshold) { Double duration = 0.0; String startAlert = null; Map<String, Object> result = new HashMap<>(); result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, false); List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresObject; for(Map<String, Object> currentMeasure : measures) { String zoneAirTempSensorName = TagConstants.Measures.ZONE_AIR_TEMP_SENSOR.getMeasureName(); String zoneAirTempHeatingSpName = TagConstants.Tags.ZONE_AIR_TEMP_EFFECTIVE_SP_HEATING.getTagName(); String eventTsName = TagConstants.Measures.EVENT_TS.getMeasureName(); if (currentMeasure.get(zoneAirTempSensorName) != null && currentMeasure.get(zoneAirTempHeatingSpName) != null && currentMeasure.get(eventTsName) != null) { Double currentZoneAirTempSensor = (Double) currentMeasure.get(zoneAirTempSensorName); Double currentZoneAirEffectiveSp = (Double) currentMeasure.get(zoneAirTempHeatingSpName); GeneralUtil.log(RulesUtil.TOO_COLD_SETPOINT, GeneralUtil.LEVEL_INFO, "Comparing if currentZoneAirTempSensor: " + currentZoneAirTempSensor + " is < currentHeatingSp: " + currentZoneAirEffectiveSp + " - setpointOffset: " + setpointOffset); if (currentZoneAirTempSensor < currentZoneAirEffectiveSp - setpointOffset) { GeneralUtil.log(RulesUtil.TOO_COLD_SETPOINT, GeneralUtil.LEVEL_INFO, "Checking if current duration: " + duration + " is >= durationThreshold: " + durationThreshold); duration += 15.0; if (duration >= durationThreshold) { if(result.get(AlarmObject.START_ALERT_FIELDNAME) == null) { startAlert = currentMeasure.get(eventTsName).toString(); GeneralUtil.log(RulesUtil.TOO_COLD_SETPOINT, GeneralUtil.LEVEL_INFO, "Start time of alert: " + startAlert); result.put(AlarmObject.START_ALERT_FIELDNAME, startAlert); } result.put(RulesBaseFact.CONDITION_MET_FIELDNAME, true); result.put(TagConstants.Parameters.DURATION.getParameterName(), duration); } } } } return (Object) result; } ', 'UTF8'),localtimestamp,'TooColdSetpoint.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Excessive HVAC Usage After Hours'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.lang.Math; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import java.util.HashMap rule "Excessive HVAC Usage After Hours" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAggrMap: measuresAggrMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForExcessiveHVACUsageAfterHours($measuresAggrMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.EXCESSIVE_HVAC_USAGE_AFTER_HOURS); $alarmObject.setAlertType(RulesUtil.EXCESSIVE_HVAC_USAGE_AFTER_HOURS); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_COST); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.EXCESSIVE_HVAC_USAGE_AFTER_HOURS, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForExcessiveHVACUsageAfterHours(Object measuresMapObject, Object parametersObject, Object alarmObject) { boolean faultDetected = false; if(measuresMapObject == null || parametersObject == null) { return faultDetected; } List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresMapObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; List<String> hvacStatusOnRuntimeTagNames = Arrays.asList(TagConstants.Tags.RTU_HEAT_STAGE_1_ON_RUNTIME.getTagName(), TagConstants.Tags.RTU_COOL_STAGE_1_ON_RUNTIME.getTagName(), TagConstants.Tags.AHU_COOL_STAGE_1_ON_RUNTIME.getTagName(), TagConstants.Tags.AHU_HEAT_STAGE_1_ON_RUNTIME.getTagName()); String excessiveHVACUsageAfterHoursRuleName = RulesUtil.EXCESSIVE_HVAC_USAGE_AFTER_HOURS; List<String> requiredTags = new ArrayList<>(); requiredTags.add(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveHVACUsageAfterHoursRuleName)); requiredTags.addAll(hvacStatusOnRuntimeTagNames); if(!measures.isEmpty() && !parameters.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measures.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areAnyTagsValid(excessiveHVACUsageAfterHoursRuleName, tagsToBeChecked, requiredTags)) { GeneralUtil.log(excessiveHVACUsageAfterHoursRuleName, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(excessiveHVACUsageAfterHoursRuleName, GeneralUtil.LEVEL_WARN, "One or more of these is empty: measures, tags, or parameters"); return faultDetected; } Object userThr = parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveHVACUsageAfterHoursRuleName)); if(userThr == null){ GeneralUtil.log(excessiveHVACUsageAfterHoursRuleName, GeneralUtil.LEVEL_INFO, "userThreshold is null"); return faultDetected; } Double userThreshold = (Double) parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveHVACUsageAfterHoursRuleName)); Map<String, Object> results = (Map<String, Object>) getResultExcessiveHVACUsageAfterHours(measuresMapObject, (Object) hvacStatusOnRuntimeTagNames, (Object) userThreshold); faultDetected = (boolean) results.get("detectFault"); if(!faultDetected) { return faultDetected; } String startAlertTime = (String) results.get("startAlert"); Double duration = (Double) results.get("duration"); AlarmObject alarm = (AlarmObject) alarmObject; String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.EXCESSIVE_HVAC_USAGE_AFTER_HOURS); if (parameters.get(severityKeyName) != null) { alarm.setSeverity((Double) parameters.get(severityKeyName)); } alarm.setDuration(duration); alarm.setTimeOfAlert(startAlertTime); alarm.setFrequency(AlarmObject.FREQUENCY_DAILY); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; return faultDetected; } /* getting the total runtime for eacht tag considered*/ function Object getResultExcessiveHVACUsageAfterHours(Object measuresMapObject, Object hvacStatusOnRuntimeTagNames, Object threshold){ Map<String, Object> result = new HashMap<>(); String startAlert = null; boolean detectFault = false; double timeThreshold = (double) threshold; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresMapObject; List<String> hvacStatusOnRuntimeTags = (List<String>) hvacStatusOnRuntimeTagNames; Double sumHeatAndColdStage1OnRuntime = 0.0; Double duration = 0.0; Double currentValue = 0.0; for (Map<String, Object> currentMapMeasure: measures){ for (String currentTag: hvacStatusOnRuntimeTags){ if (currentMapMeasure.get(currentTag) != null){ currentValue = (Double) currentMapMeasure.get(currentTag); sumHeatAndColdStage1OnRuntime += currentValue; if (sumHeatAndColdStage1OnRuntime > timeThreshold){ detectFault = true; duration += currentValue; if(startAlert != null) { startAlert = currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); } } } } } result.put("detectFault", detectFault); result.put("startAlert", startAlert); result.put("duration", duration); GeneralUtil.log(RulesUtil.EXCESSIVE_HVAC_USAGE_AFTER_HOURS, GeneralUtil.LEVEL_INFO, "sumHeatAndColdStage1OnRuntime: " + sumHeatAndColdStage1OnRuntime + " userThreshold " + timeThreshold + "Start Alert time" + startAlert); return (Object) result; } ', 'UTF8'),localtimestamp,'ExcessiveHVACUsageAfterHours.drl',NULL,DEFAULT);
INSERT INTO emsdev_emsrules.document_log(document_log_id,document_uid,document_type,document_raw,document_timestamp,document_filename,external_ref_id,entry_timestamp) VALUES (DEFAULT,(SELECT emsdev_emsrules.rule.document_uid FROM emsdev_emsrules.rule WHERE emsdev_emsrules.rule.rule_name='Excessive Lighting Usage After Hours'),'DRL',convert_to('package com.ge.current.em.rules; import java.lang.Double; import java.lang.Math; import java.io.Serializable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import java.util.Map; import com.ge.current.em.entities.analytics.*; import com.ge.current.em.util.TagConstants; import com.ge.current.em.util.GeneralUtil; import com.ge.current.em.util.RulesUtil import java.util.HashMap rule "Excessive Lighting Usage After Hours" dialect "java" no-loop true when $data : RulesBaseFact($assetId: assetId, $tagsMap: tagsMap, $segmentId: segmentId, $enterpriseId: enterpriseId, $siteId: siteId, $measuresAggrMap: measuresAggrMap, $alarmObject: alarmObject, $conditionMet: conditionMet, $parameters: parameters, detectFaultForExcessiveLightingUsageAfterHours($measuresAggrMap, $parameters, $alarmObject)) then $alarmObject.setAssetId($assetId); $alarmObject.setAlertName(RulesUtil.EXCESSIVE_LIGHTING_USAGE_AFTER_HOURS); $alarmObject.setAlertType(RulesUtil.EXCESSIVE_LIGHTING_USAGE_AFTER_HOURS); $alarmObject.setCategory(RulesUtil.CATEGORY); $alarmObject.setFaultCategory(RulesUtil.FAULT_CATEGORY_COST); $data.setAlarmObject($alarmObject); $data.setConditionMet(true); GeneralUtil.log(RulesUtil.EXCESSIVE_LIGHTING_USAGE_AFTER_HOURS, GeneralUtil.LEVEL_INFO, "Alarm triggered."); end function boolean detectFaultForExcessiveLightingUsageAfterHours(Object measuresMapObject, Object parametersObject, Object alarmObject ) { boolean faultDetected = false; if(measuresMapObject == null || parametersObject == null) { return faultDetected; } List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresMapObject; Map<String, Object> parameters = (Map<String, Object>) parametersObject; String indoorLightingStatusOnRuntimeTagName = TagConstants.Tags.INDOOR_LIGHTING_STATUS_ON_RUNTIME.getTagName(); String excessiveLightingUsageAfterHoursRuleName = RulesUtil.EXCESSIVE_LIGHTING_USAGE_AFTER_HOURS; List<String> requiredTags = Arrays.asList(indoorLightingStatusOnRuntimeTagName, TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveLightingUsageAfterHoursRuleName)); if(!measures.isEmpty() && !parameters.isEmpty()){ List<String> tagsToBeChecked = new ArrayList<>(); tagsToBeChecked.addAll(measures.get(0).keySet()); tagsToBeChecked.addAll(parameters.keySet()); if(!RulesUtil.areTagsValid(excessiveLightingUsageAfterHoursRuleName, tagsToBeChecked, requiredTags)) { GeneralUtil.log(excessiveLightingUsageAfterHoursRuleName, GeneralUtil.LEVEL_INFO, "Tags are not valid."); return faultDetected; } } else { GeneralUtil.log(excessiveLightingUsageAfterHoursRuleName, GeneralUtil.LEVEL_WARN, "One or more of these is empty: measures, tags, or parameters"); return faultDetected; } Object userThr = parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveLightingUsageAfterHoursRuleName)); if(userThr == null){ GeneralUtil.log(excessiveLightingUsageAfterHoursRuleName, GeneralUtil.LEVEL_INFO, "userThreshold is null"); return faultDetected; } Double userThreshold = (Double) parameters.get(TagConstants.Parameters.USER_THRESHOLD.getParameterName() + RulesUtil.getFDSINumber(excessiveLightingUsageAfterHoursRuleName)); Map<String, Object> results = (Map<String, Object>) getResultLightingUsageAfterHours(measuresMapObject, (Object) indoorLightingStatusOnRuntimeTagName, (Object) userThreshold); faultDetected = (boolean) results.get("detectFault"); if(!faultDetected) { return faultDetected; } String startAlertTime = (String) results.get("startAlert"); Double duration = (Double) results.get("duration"); AlarmObject alarm = (AlarmObject) alarmObject; String severityKeyName = TagConstants.Parameters.SEVERITY.getParameterName() + RulesUtil.getFDSINumber(RulesUtil.EXCESSIVE_LIGHTING_USAGE_AFTER_HOURS); if (parameters.get(severityKeyName) != null) { alarm.setSeverity((Double) parameters.get(severityKeyName)); } alarm.setDuration(duration); alarm.setTimeOfAlert(startAlertTime); alarm.setQueryTable(AlarmObject.QUERY_TABLE_BY_MINUTE); alarmObject = alarm; return faultDetected; } function Object getResultLightingUsageAfterHours(Object measuresMapObject, Object indoorLightingStatusOnRuntimeTagName, Object threshold){ Map<String, Object> result = new HashMap<>(); String startAlert = null; boolean detectFault = false; double timeThreshold = (double) threshold; List<Map<String, Object>> measures = (List<Map<String, Object>>) measuresMapObject; String indoorLightingStatusOnRuntime = (String) indoorLightingStatusOnRuntimeTagName; Double sumIndoorLightingStatusOnRuntime = 0.0; Double duration = 0.0; Double currentValue = 0.0; for (Map<String, Object> currentMapMeasure: measures){ if (currentMapMeasure.get(indoorLightingStatusOnRuntime) != null){ currentValue = (Double) currentMapMeasure.get(indoorLightingStatusOnRuntime); sumIndoorLightingStatusOnRuntime += currentValue; if (sumIndoorLightingStatusOnRuntime > timeThreshold){ detectFault = true; duration += currentValue; if(startAlert != null) { startAlert = currentMapMeasure.get(TagConstants.Measures.EVENT_TS.getMeasureName()).toString(); } } } } result.put("detectFault", detectFault); result.put("startAlert", startAlert); result.put("duration", duration); GeneralUtil.log(RulesUtil.EXCESSIVE_LIGHTING_USAGE_AFTER_HOURS, GeneralUtil.LEVEL_INFO, "totalIndoorLightingStatusOnRuntime: " + sumIndoorLightingStatusOnRuntime + " userThreshold " + timeThreshold + "Start Alert time" + startAlert); return (Object) result; } ', 'UTF8'),localtimestamp,'ExcessiveLightingUsageAfterHours.drl',NULL,DEFAULT);
